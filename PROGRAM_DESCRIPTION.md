# Полная документация программного комплекса спектрального анализа

<a id="oglavlenie"></a>
## Оглавление
1. [Введение и назначение](#vvedenie-i-naznachenie)
2. [Глава 1. Общий алгоритм работы](#glava-1-obschij-algoritm-raboty)
   1. [1.1. Подготовка окружения](#1-1-podgotovka-okruzheniya)
   2. [1.2. Запуск из командной строки](#1-2-zapusk-iz-komandnoj-stroki)
   3. [1.3. Сканирование структуры каталогов](#1-3-skanirovanie-struktury-katalogov)
   4. [1.4. Чтение исходных сигналов](#1-4-chtenie-ishodnyh-signalov)
   5. [1.5. Загрузка теоретических оценок](#1-5-zagruzka-teoreticheskih-ocenok)
   6. [1.6. Нормализация и препроцессинг сигналов](#1-6-normalizaciya-i-preprocessing-signalov)
   7. [1.7. Расчёт первичных оценок ESPRIT](#1-7-raschet-pervichnyh-ocenok-esprit)
   8. [1.8. Фильтрация и подготовка кандидатов](#1-8-filtraciya-i-podgotovka-kandidatov)
   9. [1.9. Резервный спектральный поиск](#1-9-rezervnyj-spektralnyj-poisk)
   10. [1.10. Формирование комбинаций и границы оптимизации](#1-10-formirovanie-kombinacij-i-granicy-optimizacii)
   11. [1.11. Нелинейная аппроксимация сигналов](#1-11-nelinejnaya-approksimaciya-signalov)
   12. [1.12. Критерии успешности и выбор лучшего решения](#1-12-kriterii-uspeshnosti-i-vybor-luchshego-resheniya)
   13. [1.13. Обработка случаев с единственным диапазоном](#1-13-obrabotka-sluchaev-s-edinstvennym-diapazonom)
   14. [1.14. Сохранение результатов и экспорт](#1-14-sohranenie-rezultatov-i-eksport)
   15. [1.15. Генерация отчётов и визуализация](#1-15-generaciya-otchetov-i-vizualizaciya)
   16. [1.16. Завершение обработки и отчётность](#1-16-zavershenie-obrabotki-i-otchetnost)
3. [Глава 2. Математические методы и их обоснование](#glava-2-matematicheskie-metody-i-ih-obosnovanie)
   1. [2.1. Математическая модель сигнала](#2-1-matematicheskaya-model-signala)
   2. [2.2. Дискретизация и единицы измерения](#2-2-diskretizaciya-i-edinicy-izmereniya)
   3. [2.3. Построение корреляционных матриц для ESPRIT](#2-3-postroenie-korrelyacionnyh-matric-dlya-esprit)
   4. [2.4. SVD-разложение и отбор сингулярных компонент](#2-4-svd-razlozhenie-i-otbor-singulyarnyh-komponent)
   5. [2.5. Восстановление частот из собственных значений](#2-5-vosstanovlenie-chastot-iz-sobstvennyh-znachenij)
   6. [2.6. Оценивание времен затухания](#2-6-ocenivanie-vremen-zatuhaniya)
   7. [2.7. Спектральные методы резервного поиска](#2-7-spektralnye-metody-rezervnogo-poiska)
   8. [2.8. Нелинейная минимизация невязки](#2-8-nelinejnaya-minimizaciya-nevyazki)
   9. [2.9. Оценка доверительных интервалов](#2-9-ocenka-doveritelnyh-intervalov)
   10. [2.10. Критерии качества и метрики стоимости](#2-10-kriterii-kachestva-i-metriki-stoimosti)
4. [Глава 3. Структуры данных и форматы файлов](#glava-3-struktury-dannyh-i-formaty-fajlov)
   1. [3.1. Сырые записи (`RawRecord`)](#3-1-syrye-zapisi-rawrecord)
   2. [3.2. Набор данных (`DataSet`)](#3-2-nabor-dannyh-dataset)
   3. [3.3. Результаты аппроксимации (`FittingResult`)](#3-3-rezultaty-approksimacii-fittingresult)
   4. [3.4. Конфигурация обработки (`ProcessingConfig`)](#3-4-konfiguraciya-obrabotki-processingconfig)
   5. [3.5. Теоретические файлы `H_*.npy` и `T_*.npy`](#3-5-teoreticheskie-fajly-h-npy-i-t-npy)
   6. [3.6. Экспортируемые таблицы](#3-6-eksportiruemye-tablicy)
5. [Глава 4. Модули и функции](#glava-4-moduli-i-funkcii)
   1. [4.1. Модуль `spectral_pipeline.__init__`](#4-1-modul-spectral-pipeline-init)
   2. [4.2. Модуль `spectral_pipeline.cli`](#4-2-modul-spectral-pipeline-cli)
   3. [4.3. Модуль `spectral_pipeline.io`](#4-3-modul-spectral-pipeline-io)
   4. [4.4. Модуль `spectral_pipeline.fit`](#4-4-modul-spectral-pipeline-fit)
   5. [4.5. Модуль `spectral_pipeline.plotting`](#4-5-modul-spectral-pipeline-plotting)
   6. [4.6. Утилита `find_freqs_and_visualize.py`](#4-6-utilita-find-freqs-and-visualize-py)
6. [Глава 5. Параметры, константы и конфигурация](#glava-5-parametry-konstanty-i-konfiguraciya)
   1. [5.1. Частотные диапазоны](#5-1-chastotnye-diapazony)
   2. [5.2. Ограничения по времени затухания](#5-2-ogranicheniya-po-vremeni-zatuhaniya)
   3. [5.3. Настройки ESPRIT](#5-3-nastrojki-esprit)
   4. [5.4. Параметры FFT и оконных функций](#5-4-parametry-fft-i-okonnyh-funkcij)
   5. [5.5. Параметры аппроксимации](#5-5-parametry-approksimacii)
   6. [5.6. Настройки визуализации](#5-6-nastrojki-vizualizacii)
   7. [5.7. Перечень переменных среды](#5-7-perechen-peremennyh-sredy)
7. [Глава 6. Обработка ошибок и диагностическое логирование](#glava-6-obrabotka-oshibok-i-diagnosticheskoe-logirovanie)
   1. [6.1. Уровни логирования](#6-1-urovni-logirovaniya)
   2. [6.2. Основные сообщения и их интерпретация](#6-2-osnovnye-soobscheniya-i-ih-interpretaciya)
   3. [6.3. Диагностика неуспешных аппроксимаций](#6-3-diagnostika-neuspeshnyh-approksimacij)
   4. [6.4. Отладка ESPRIT](#6-4-otladka-esprit)
   5. [6.5. Анализ резервного поиска](#6-5-analiz-rezervnogo-poiska)
8. [Глава 7. Тестирование и верификация](#glava-7-testirovanie-i-verifikaciya)
   1. [7.1. Модульные тесты](#7-1-modulnye-testy)
   2. [7.2. Интеграционные проверки](#7-2-integracionnye-proverki)
   3. [7.3. Воспроизводимость результатов](#7-3-vosproizvodimost-rezultatov)
   4. [7.4. Метрики производительности](#7-4-metriki-proizvoditelnosti)
9. [Глава 8. Руководство пользователя](#glava-8-rukovodstvo-polzovatelya)
   1. [8.1. Подготовка данных](#8-1-podgotovka-dannyh)
   2. [8.2. Сценарии запуска](#8-2-scenarii-zapuska)
   3. [8.3. Настройка параметров обработки](#8-3-nastrojka-parametrov-obrabotki)
   4. [8.4. Анализ отчётов и графиков](#8-4-analiz-otchetov-i-grafikov)
   5. [8.5. Типовые проблемы и решения](#8-5-tipovye-problemy-i-resheniya)
10. [Глава 9. Внутренние соглашения и стиль кода](#glava-9-vnutrennie-soglasheniya-i-stil-koda)
   1. [9.1. Именование](#9-1-imenovanie)
   2. [9.2. Стандарты документирования](#9-2-standarty-dokumentirovaniya)
   3. [9.3. Обработка численных ошибок](#9-3-obrabotka-chislennyh-oshibok)
   4. [9.4. Работа с единицами измерения](#9-4-rabota-s-edinicami-izmereniya)
   5. [9.5. Поддержка расширений и модификаций](#9-5-podderzhka-rasshirenij-i-modifikacij)
11. [Глава 10. Приложения](#glava-10-prilozheniya)
   1. [10.1. Приложение A. Подробный пример обработки одной пары](#10-1-prilozhenie-a-podrobnyj-primer-obrabotki-odnoj-pary)
   2. [10.2. Приложение B. Таблицы параметров и постоянных](#10-2-prilozhenie-b-tablicy-parametrov-i-postoyannyh)
   3. [10.3. Приложение C. Формат логов](#10-3-prilozhenie-c-format-logov)
   4. [10.4. Приложение D. Псевдокод ключевых алгоритмов](#10-4-prilozhenie-d-psevdokod-klyuchevyh-algoritmov)
   5. [10.5. Приложение E. Список используемых сокращений](#10-5-prilozhenie-e-spisok-ispolzuemyh-sokraschenij)
   6. [10.6. Приложение F. План расширения функциональности](#10-6-prilozhenie-f-plan-rasshireniya-funkcionalnosti)
12. [Глава 11. Детальная декомпозиция функций](#glava-11-detalnaya-dekompoziciya-funkcij)
   1. [11.1. `spectral_pipeline.cli.main`](#11-1-spectral-pipeline-cli-main)
   2. [11.2. `spectral_pipeline.io.load_records`](#11-2-spectral-pipeline-io-load-records)
   3. [11.3. `_load_guess`](#11-3-load-guess)
   4. [11.4. `_esprit_freqs_and_decay`](#11-4-esprit-freqs-and-decay)
   5. [11.5. `_search_candidates`](#11-5-search-candidates)
   6. [11.6. `_fallback_peak`](#11-6-fallback-peak)
   7. [11.7. `fit_pair`](#11-7-fit-pair)
   8. [11.8. `process_pair`](#11-8-process-pair)
   9. [11.9. `process_lf_only`](#11-9-process-lf-only)
   10. [11.10. `export_freq_tables`](#11-10-export-freq-tables)
13. [Глава 12. Дополнительные сценарии и практические рекомендации](#glava-12-dopolnitelnye-scenarii-i-prakticheskie-rekomendacii)
   1. [12.1. Настройка ESPRIT под шумные данные](#12-1-nastrojka-esprit-pod-shumnye-dannye)
   2. [12.2. Работа с короткими сигналами](#12-2-rabota-s-korotkimi-signalami)
   3. [12.3. Поддержка дополнительных диапазонов](#12-3-podderzhka-dopolnitelnyh-diapazonov)
   4. [12.4. Использование пользовательских оконных функций](#12-4-ispolzovanie-polzovatelskih-okonnyh-funkcij)
   5. [12.5. Работа в пакетном режиме](#12-5-rabota-v-paketnom-rezhime)
14. [Глава 13. Расширенные данные о визуализации](#glava-13-rasshirennye-dannye-o-vizualizacii)
   1. [13.1. Структура фигур в `visualize_stacked`](#13-1-struktura-figur-v-visualize-stacked)
   2. [13.2. Подготовка данных для графиков](#13-2-podgotovka-dannyh-dlya-grafikov)
   3. [13.3. Настройка подписей и легенд](#13-3-nastrojka-podpisej-i-legend)
   4. [13.4. Работа с масштабами осей](#13-4-rabota-s-masshtabami-osej)
15. [Глава 14. Полный перечень лог-сообщений](#glava-14-polnyj-perechen-log-soobschenij)
   1. [14.1. Сообщения уровня INFO](#14-1-soobscheniya-urovnya-info)
   2. [14.2. Сообщения уровня WARNING](#14-2-soobscheniya-urovnya-warning)
   3. [14.3. Сообщения уровня DEBUG](#14-3-soobscheniya-urovnya-debug)
   4. [14.4. Сообщения уровня ERROR](#14-4-soobscheniya-urovnya-error)
16. [Глава 15. Контроль качества данных](#glava-15-kontrol-kachestva-dannyh)
   1. [15.1. Проверка входных сигналов](#15-1-proverka-vhodnyh-signalov)
   2. [15.2. Проверка теоретических файлов](#15-2-proverka-teoreticheskih-fajlov)
   3. [15.3. Проверка результатов](#15-3-proverka-rezultatov)
17. [Приложение G. Расширенная таблица параметров функций](#prilozhenie-g-rasshirennaya-tablica-parametrov-funkcij)
18. [Приложение H. Пошаговая проверка после обновления кода](#prilozhenie-h-poshagovaya-proverka-posle-obnovleniya-koda)
19. [Приложение I. Сводная таблица единиц измерения](#prilozhenie-i-svodnaya-tablica-edinic-izmereniya)
20. [Приложение J. Глоссарий терминов](#prilozhenie-j-glossarij-terminov)
21. [Приложение K. Рекомендации по адаптации к новым экспериментам](#prilozhenie-k-rekomendacii-po-adaptacii-k-novym-eksperimentam)
22. [Приложение L. Детальное описание параметров оптимизатора](#prilozhenie-l-detalnoe-opisanie-parametrov-optimizatora)
23. [Приложение M. Хронология обработки одной пары (расширенная)](#prilozhenie-m-hronologiya-obrabotki-odnoj-pary-rasshirennaya)
24. [Приложение N. Примеры строк логов и их трактовка](#prilozhenie-n-primery-strok-logov-i-ih-traktovka)
25. [Приложение O. Алгоритм оценки времен затухания по временной области](#prilozhenie-o-algoritm-ocenki-vremen-zatuhaniya-po-vremennoj-oblasti)
26. [Приложение P. Контрольная таблица допустимых отклонений](#prilozhenie-p-kontrolnaya-tablica-dopustimyh-otklonenij)
27. [Приложение Q. Диагностика артефактов в спектрах](#prilozhenie-q-diagnostika-artefaktov-v-spektrah)
28. [Приложение R. Пошаговая настройка визуализации без спектра](#prilozhenie-r-poshagovaya-nastrojka-vizualizacii-bez-spektra)
29. [Приложение S. Управление производительностью](#prilozhenie-s-upravlenie-proizvoditelnostyu)
30. [Приложение T. Проверка корректности теоретических кривых](#prilozhenie-t-proverka-korrektnosti-teoreticheskih-krivyh)
31. [Приложение U. Пример шаблона отчёта](#prilozhenie-u-primer-shablona-otcheta)
32. [Приложение V. Дополнительные рекомендации по тестированию](#prilozhenie-v-dopolnitelnye-rekomendacii-po-testirovaniyu)

---

<a id="vvedenie-i-naznachenie"></a>
## Введение и назначение
Программный комплекс `approximation_with_GPT` автоматизирует обработку временных рядов, полученных в экспериментах по спектроскопии с переменными температурой и магнитным полем. Для каждого набора измерений выделяются резонансные частоты и времена затухания двух мод (LF и HF). Система объединяет методы оценки частотных характеристик (ESPRIT, FFT, авторегрессионные подходы) с последующей нелинейной аппроксимацией во временной области. Документ описывает каждый шаг работы, обосновывает используемые математические методы и перечисляет функции, обеспечивающие исполнение алгоритма.

Особое внимание уделено интеграции с теоретическими оценками, которые поставляются в файлах первого приближения. Эти файлы содержат не только частоты, но и времена затухания в наносекундах. Программа учитывает допустимое отклонение ±20% от теории при подборе кандидатов и в ходе оптимизации. Визуализация выводит частоты, времена затухания и амплитуды в едином отчёте, что облегчает сопоставление теории и эксперимента.

Ниже приведено детальное описание всех компонентов. Документ составлен таким образом, чтобы по нему можно было восстановить внутреннюю архитектуру, переписать реализацию или адаптировать её к новым условиям эксперимента.

---

<a id="glava-1-obschij-algoritm-raboty"></a>
## Глава 1. Общий алгоритм работы
Алгоритм обработки представляет собой последовательность из множества этапов. Каждый шаг строго определён, поскольку последующие действия зависят от полноты данных и корректности промежуточных оценок. Все процедуры реализованы в модуле `spectral_pipeline`, а пользователь взаимодействует с системой через функции `spectral_pipeline.cli` или утилиту `find_freqs_and_visualize.py`.

<a id="1-1-podgotovka-okruzheniya"></a>
### 1.1. Подготовка окружения
1. Устанавливаются зависимости, перечисленные в `requirements.txt`: `numpy`, `scipy`, `matplotlib`, `pandas`, `openpyxl`, `click` и другие.
2. Пользователь формирует структуру каталогов: в рабочей папке должны находиться подкаталоги `data`, `logs`, `output` (создаётся автоматически при визуализации), а также файлы первого приближения `H_<H>.npy` или `T_<T>.npy`, если теория известна.
3. Переменная окружения `PYTHONPATH` должна включать корень репозитория, чтобы модуль `spectral_pipeline` корректно импортировался.
4. Для воспроизводимости можно зафиксировать генератор псевдослучайных чисел (`numpy.random.seed`).
5. Перед запуском проверяется, что в системе доступны кодеки matplotlib и шрифты для корректного отображения кириллических подписей.

<a id="1-2-zapusk-iz-komandnoj-stroki"></a>
### 1.2. Запуск из командной строки
1. Базовый способ запуска: `python find_freqs_and_visualize.py --root /path/to/data`.
2. Аргументы CLI задаются через модуль `click`:
   - `--root`: обязательный, путь к каталогу, содержащему `data`.
   - `--export`: флаг, включает экспорт результатов в Excel.
   - `--no-spectra`: флаг, отключает построение спектров в отчётах.
   - `--log-level`: уровень логирования (`INFO` по умолчанию).
3. CLI вызывает `spectral_pipeline.cli.main`, который инициализирует `ProcessingConfig` и запускает обработку.
4. По завершении CLI возвращает код выхода 0 и выводит путь к отчётам, либо поднимает исключение при критической ошибке (например, отсутствуют данные).

<a id="1-3-skanirovanie-struktury-katalogov"></a>
### 1.3. Сканирование структуры каталогов
1. Функция `load_records` принимает корневой путь и ищет файлы `*.dat` в подкаталоге `data`.
2. Имя файла должно содержать параметры эксперимента: мощность насоса, длину волны, силу магнитного поля и температуру. Парсер извлекает значения температуры (К) и поля (мТ) из шаблона `_H_<field>_..._T_<temp>...`.
3. Сформированные объекты `RawRecord` группируются по паре `(field_mT, temp_K)`.
4. Для каждой группы проверяется наличие двух файлов: `*_HF_*.dat` и `*_LF_*.dat`. Если один из диапазонов отсутствует, создаётся запись только с доступным диапазоном; позднее будет применён специальный алгоритм `process_lf_only`.
5. Логирование уровня `INFO` фиксирует число обнаруженных наборов, количество файлов и список температур/полей.

<a id="1-4-chtenie-ishodnyh-signalov"></a>
### 1.4. Чтение исходных сигналов
1. Внутри `DataSet.from_records` вызывается `_load_signal`, которая читает файлы `*.dat` в формате: первая колонка — время (наносекунды), остальные — значения сигналов.
2. Временная сетка преобразуется в секунды (умножением на `NS`), значения сигнала вычитаются из среднего и масштабируются так, чтобы амплитуда укладывалась в диапазон ±1.
3. Если длина сигналов HF и LF различается, применяется ресемплинг по линейной интерполяции, чтобы числа точек совпали.
4. Для уменьшения влияния шумов концы сигналов могут усекаться согласно параметру `config.trim_after_minimum`.
5. Результирующие массивы хранятся в `DataSet.signal_lf` и `DataSet.signal_hf` в формате `numpy.ndarray` типа `float64`.

<a id="1-5-zagruzka-teoreticheskih-ocenok"></a>
### 1.5. Загрузка теоретических оценок
1. После чтения сигналов `DataSet` пытается загрузить файл первого приближения:
   - Сначала проверяется наличие `H_<field>.npy`.
   - Если файл не найден, выполняется поиск `T_<temp>.npy`.
   - Если ни один файл не найден, `initial_guess` остаётся пустым.
2. Формат файла: массив `numpy` с пятью строками:
   1. Значения основной оси (температура или поле, в зависимости от типа файла).
   2. Частоты HF в ГГц.
   3. Частоты LF в ГГц.
   4. Времена затухания HF в наносекундах.
   5. Времена затухания LF в наносекундах.
3. Программа находит индекс элемента, наиболее близкого к текущему значению оси. Соответствующие частоты и времена затухания считываются и конвертируются из ГГц в Гц, из наносекунд в секунды.
4. Теоретические значения сохраняются в `DataSet.freq_guess_hf`, `DataSet.freq_guess_lf`, `DataSet.tau_guess_hf`, `DataSet.tau_guess_lf`.
5. Дополнительно `DataSet` запоминает, по какой оси была прочитана теория, чтобы при визуализации корректно построить кривые.

<a id="1-6-normalizaciya-i-preprocessing-signalov"></a>
### 1.6. Нормализация и препроцессинг сигналов
1. Для каждого диапазона вычисляется шаг дискретизации `dt` и частота дискретизации `fs`.
2. Сигналы центрируются и нормируются по RMS, чтобы обеспечить сопоставимость амплитуд при разных условиях.
3. Временные ряды LF и HF синхронизируются по длине: выбирается минимальное количество точек, остальные обрезаются.
4. Вычисляется оконная функция (по умолчанию Хэмминга) для подавления утечек в спектральном анализе.
5. Готовые массивы передаются в процедуры ESPRIT и резервного поиска.

<a id="1-7-raschet-pervichnyh-ocenok-esprit"></a>
### 1.7. Расчёт первичных оценок ESPRIT
1. Функция `_esprit_freqs_and_decay` строит корреляционные матрицы сигналов для двух соседних блоков длиной `NS`.
2. Формируются два массива: `X0` и `X1`, где `X0` содержит сегменты `signal[i:i+NS]`, а `X1` — `signal[i+1:i+NS+1]`.
3. Вычисляется матрица перекрёстных корреляций `R = X0.conj().T @ X1` и автокорреляционная матрица `S = X0.conj().T @ X0`.
4. Через сингулярное разложение `S` находится ортонормированный базис подпространства сигналов, соответствующий двум наибольшим сингулярным значениям.
5. Решается обобщённая задача собственных значений `S_sub^{-1} R_sub`, где индексы `sub` указывают на усечённые матрицы размером 2×2.
6. Комплексные собственные значения `λ_k` используются для оценки частот и времён затухания.
7. Значения с отрицательными или нулевыми временами затухания отбрасываются. В лог выводится количество исключённых компонент.
8. Частоты пересчитываются из радиан в Гц, затем в ГГц для удобства фильтрации.

<a id="1-8-filtraciya-i-podgotovka-kandidatov"></a>
### 1.8. Фильтрация и подготовка кандидатов
1. Функция `_search_candidates` принимает результаты ESPRIT и делит их на LF и HF по заранее заданным диапазонам (`LF_BAND`, `HF_BAND`).
2. Если присутствуют теоретические значения, допустимые окна устанавливаются как `f_guess ± 5 ГГц` и `τ_guess · (1 ± 0.2)`.
3. При отсутствии теории используются глобальные границы: LF 4–16 ГГц, HF 20–40 ГГц (по умолчанию).
4. Для каждой подходящей частоты формируется кортеж `(f, τ, weight, source)`:
   - `f` — частота в ГГц.
   - `τ` — время затухания в наносекундах.
   - `weight` — числовая оценка доверия (ESPRIT = 0.7, теория = 1.0, FFT = 0.4).
   - `source` — строка с названием источника.
5. Если фильтрация не даёт ни одного HF кандидата, окно автоматически расширяется до `±10 ГГц` вокруг теоретической частоты. После расширения алгоритм повторяется с теми же правилами исключения по времени.
6. Все добавленные кандидаты сортируются по абсолютному отклонению от теории и по весу. В списках хранится не менее трёх лучших вариантов даже без теории (используются верхние по модулю амплитуды компоненты ESPRIT).

<a id="1-9-rezervnyj-spektralnyj-poisk"></a>
### 1.9. Резервный спектральный поиск
1. Если ESPRIT не предоставил кандидатов или их недостаточно, вызывается `_fallback_peak`.
2. Выполняются следующие шаги:
   1. Вычисление спектра методом FFT с оконной функцией Хэмминга.
   2. Первичная фильтрация по порогам `height` и `prominence`, зависящим от стандартного отклонения спектра в диапазоне.
   3. Если пиков нет, пороги снижаются (последовательность коэффициентов 0.3, 0.05, 0.01).
   4. При нахождении пика рядом с границей диапазон расширяется на `expansion_step_GHz` (по умолчанию 2 ГГц) и процесс повторяется, но не более `max_expansions` раз.
   5. Если даже после расширения нет явных максимумов, выбирается точка с максимальной амплитудой, однако такой кандидат помечается минимальным весом.
3. Для резерва также используются метод Бюрга и метод Уэлча, если в FFT не обнаружено значимых максимумов. Полученные оценки усредняются и добавляются в список кандидатов.
4. Время затухания для резервных кандидатов оценивается по отношению амплитуд в временной области: рассчитывается линейная регрессия логарифма огибающей. Результат ограничивается диапазоном `[0.1 τ_guess, 5 τ_guess]` при наличии теории и `[1e-10, 5e-6]` при её отсутствии.

<a id="1-10-formirovanie-kombinacij-i-granicy-optimizacii"></a>
### 1.10. Формирование комбинаций и границы оптимизации
1. После объединения всех источников строятся списки кандидатов LF и HF.
2. Конфигурация задаёт максимальное число комбинаций (`max_combinations`), что предотвращает экспоненциальный рост числа попыток. Обычно ограничение составляет 25 комбинаций.
3. Для каждой комбинации формируются нижние и верхние границы параметров:
   - `f_min = f_candidate · (1 - δ_f)` и `f_max = f_candidate · (1 + δ_f)`, где δ_f = 0.1 при наличии теории и 0.3 без неё.
   - `τ_min = τ_candidate · (1 - 0.2)` и `τ_max = τ_candidate · (1 + 0.2)` при наличии теории. Если теория отсутствует, используются глобальные константы `TAU_MIN` и `TAU_MAX`.
4. Начальные амплитуды выбираются по значениям сигналов в первые 50 точек (метод наименьших квадратов). Фазы стартуют из диапазона `[-π/2, π/2]` и подбираются так, чтобы приблизительно совпасть с положением первого экстремума.
5. Для каждой комбинации формируется структура `InitialGuess`, содержащая все стартовые параметры.

<a id="1-11-nelinejnaya-approksimaciya-signalov"></a>
### 1.11. Нелинейная аппроксимация сигналов
1. Основная функция `fit_pair` вызывает `scipy.optimize.least_squares` с методом Левенберга–Марквардта (`method='trf'`) и масштабированием параметров.
2. Вектор параметров: `(A1, A2, f1, f2, τ1, τ2, φ1, φ2, C)`.
3. Функция невязки вычисляет разницу между измеренным сигналом и моделью:

\[
r_i = s_{\text{meas}}(t_i) - \sum_{k=1}^{2} A_k e^{-t_i/τ_k} \cos(2π f_k t_i + φ_k) - C.
\]

4. Веса невязки задаются экспоненциальным затуханием, чтобы поздние точки с большим шумом не доминировали.
5. На каждой итерации контролируется, что параметры не выходят за границы. Если оптимизатор попытался выйти за пределы, параметр прижимается к границе и итерация повторяется с уменьшенным шагом.
6. После сходимости вычисляется ковариационная матрица `cov = (J^T J)^{-1} σ^2`, где `σ^2 = cost / (N - p)`.
7. Стандартные отклонения по частотам и временам затухания преобразуются в ГГц и наносекунды соответственно для удобства вывода.
8. При наличии только одного диапазона (LF-only режим) оптимизируется укороченный вектор параметров `(A1, f1, τ1, φ1, C)`.

<a id="1-12-kriterii-uspeshnosti-i-vybor-luchshego-resheniya"></a>
### 1.12. Критерии успешности и выбор лучшего решения
1. После каждой попытки рассчитывается стоимость `cost = 0.5 * ||r||^2`.
2. Лучшим решением считается комбинация с минимальной стоимостью, удовлетворяющая условиям:
   - `cost <= MAX_COST` (значение по умолчанию 100).
   - Частоты не выходят за глобальные диапазоны.
   - Времена затухания находятся в допустимом интервале и не противоречат теории (если она присутствует).
3. При равных стоимостях выбирается решение с минимальным суммарным отклонением от теории (нормируется по относительным величинам).
4. Если ни одна комбинация не прошла критерии, пара помечается как неуспешная, что отражается в сводной статистике.

<a id="1-13-obrabotka-sluchaev-s-edinstvennym-diapazonom"></a>
### 1.13. Обработка случаев с единственным диапазоном
1. Если отсутствует HF сигнал, функция `process_lf_only` выполняет те же шаги, но игнорирует HF часть.
2. Кандидаты формируются из ESPRIT и FFT по LF диапазону.
3. Нелинейная подгонка использует однотональную модель. Теоретические значения HF игнорируются.
4. В отчётах HF графики заменяются пустыми подписями, а экспортируемая таблица оставляет ячейки HF пустыми или со значением `NaN`.

<a id="1-14-sohranenie-rezultatov-i-eksport"></a>
### 1.14. Сохранение результатов и экспорт
1. После обработки всех пар создаётся список `FittingResult`.
2. Функция `export_freq_tables` формирует DataFrame для частот и времен затухания отдельно по LF и HF.
3. Таблицы сохраняются в файл `frequencies_(approximation_with_GPT).xlsx` с листами:
   - `LF_frequency_GHz`.
   - `HF_frequency_GHz`.
   - `LF_tau_ns`.
   - `HF_tau_ns`.
   - `meta` — содержит версии ПО и дату обработки.
4. Если экспорт отключён, функция не создаёт файл, но возвращает структуры данных.

<a id="1-15-generaciya-otchetov-i-vizualizaciya"></a>
### 1.15. Генерация отчётов и визуализация
1. Модуль `spectral_pipeline.plotting` строит два типа отчётов:
   - «Со спектром»: три строки (частота, время затухания, амплитуда) и столбец со спектрами.
   - «Без спектра»: три строки графиков и один столбец с легендами.
2. Для каждого поля или температуры строится отдельная фигура.
3. Теоретические кривые отображаются пунктиром и маркерами. Экспериментальные точки выводятся цветными маркерами с ошибками (если рассчитаны).
4. Подписи осей: частота (ГГц), время затухания (нс), амплитуда (отн. ед.).
5. В правой панели (при наличии спектров) отображается FFT каждого сигнала с указанием найденных пиков.

<a id="1-16-zavershenie-obrabotki-i-otchetnost"></a>
### 1.16. Завершение обработки и отчётность
1. В лог `INFO` выводится итоговая статистика: число успешных пар, средняя стоимость, наличие пропусков.
2. Создаются итоговые файлы: Excel, PDF/PNG отчёты, лог `pipeline.log`.
3. Пользователь проверяет отчёты и при необходимости корректирует теоретические файлы.
4. При следующем запуске система учитывает обновления и повторяет алгоритм.

---

<a id="glava-2-matematicheskie-metody-i-ih-obosnovanie"></a>
## Глава 2. Математические методы и их обоснование
В этом разделе приводится углублённый разбор используемых математических процедур. Каждая подсекция описывает исходные формулы, предположения, ограничения и связь с реализацией.

<a id="2-1-matematicheskaya-model-signala"></a>
### 2.1. Математическая модель сигнала
1. Сигнал записывается как сумма двух затухающих косинусоид:

\[
s(t) = A_1 e^{-t/τ_1} \cos(2π f_1 t + φ_1) + A_2 e^{-t/τ_2} \cos(2π f_2 t + φ_2) + C + ε(t).
\]

2. `A_k` — амплитуды, `f_k` — частоты, `τ_k` — времена затухания (секунды), `φ_k` — фазы, `C` — смещение, `ε(t)` — шум, предполагаемый гауссовым с нулевым средним.
3. Цель обработки — найти `(f_1, f_2, τ_1, τ_2)` при минимизации квадратичной невязки между моделью и измерениями.
4. Теоретические значения используются как априорная информация: они задают интервал поиска и веса регуляризации.

<a id="2-2-diskretizaciya-i-edinicy-izmereniya"></a>
### 2.2. Дискретизация и единицы измерения
1. Сигналы измеряются с постоянным шагом `Δt`. Для HF диапазона `fs` составляет 3 ТГц (шаг ≈ 0.333 пс), для LF — 300 ГГц (шаг ≈ 3.33 пс).
2. Все вычисления ведутся в системе SI: время — секунды, частота — Гц. Для удобства отображения и логирования используется перевод в наносекунды (времена) и гигагерцы (частоты).
3. Константа `NS = 1e-9` переводит наносекунды в секунды, `GHZ = 1e9` — гигагерцы в герцы.
4. Сигналы хранятся как массивы `float64`, что обеспечивает достаточную точность при вычислении экспонент и косинусов.

<a id="2-3-postroenie-korrelyacionnyh-matric-dlya-esprit"></a>
### 2.3. Построение корреляционных матриц для ESPRIT
1. ESPRIT использует свойства сдвиговой инвариантности сигналов. Для этого строятся корреляционные матрицы из сдвинутых копий сигнала.
2. Пусть `X` — матрица размером `NS × (N-NS)`, сформированная сдвигом по времени: `X[:, n] = signal[n:n+NS]`.
3. Определяются две матрицы:
   - `X0 = X[:, :-1]` — набор сегментов без последнего столбца.
   - `X1 = X[:, 1:]` — набор сегментов, сдвинутых на один шаг вперёд.
4. Корреляционная матрица `S = X0 X0^H` и сдвиговая корреляция `R = X0 X1^H` отражают структуру сигнала и используются в дальнейших вычислениях.
5. Чтобы стабилизировать вычисления, матрицы нормируются по числу сегментов, а также может добавляться диагональное регуляризующее слагаемое `εI` с `ε = 1e-12`.

<a id="2-4-svd-razlozhenie-i-otbor-singulyarnyh-komponent"></a>
### 2.4. SVD-разложение и отбор сингулярных компонент
1. Матрица `S` подвергается сингулярному разложению `S = U Σ U^H`.
2. Значения диагонали `Σ` сортируются по убыванию. В идеальной ситуации две первые компоненты соответствуют двум тональным модам.
3. Реализация выбирает подпространство размерности `model_rank` (по умолчанию 4, чтобы учесть возможные побочные моды). Оно задаётся матрицей `U_sub = U[:, :model_rank]`.
4. Корреляционная матрица в подпространстве `S_sub = U_sub^H S U_sub`, а сдвиговая — `R_sub = U_sub^H R U_sub`.
5. Решается обобщённая задача `R_sub v = λ S_sub v`. Собственные значения `λ` несут информацию о частотах и затуханиях.
6. Для повышения устойчивости в реализации используется функция `scipy.linalg.eig` с комплексной арифметикой двойной точности.

<a id="2-5-vosstanovlenie-chastot-iz-sobstvennyh-znachenij"></a>
### 2.5. Восстановление частот из собственных значений
1. Пусть `λ = ρ e^{iθ}`. Тогда дискретная модель предполагает, что `λ = e^{(-1/τ + i 2π f) Δt}`.
2. Частота вычисляется как `f = θ / (2π Δt)`.
3. Значение переводится в ГГц делением на `GHZ`.
4. Чтобы устранить неоднозначность на уровне ±fs/2, используется функция `np.unwrap` для фаз, обеспечивающая непрерывность.
5. Если частота выходит за физически допустимый диапазон (например, отрицательная или > 60 ГГц), значение отбрасывается.

<a id="2-6-ocenivanie-vremen-zatuhaniya"></a>
### 2.6. Оценивание времен затухания
1. Радиальная часть `ρ = |λ|` связана с временем затухания как `ρ = e^{-Δt/τ}`.
2. Следовательно, `τ = -Δt / ln(ρ)`.
3. Если `ρ >= 1`, то `τ` становится отрицательным или бесконечным. Такие компоненты считаются неустойчивыми и исключаются.
4. Значения `τ` ограничиваются нижним пределом 10 пс и верхним пределом 10 мкс, чтобы избежать численных проблем.
5. Теоретические времена затухания сравниваются с оценками ESPRIT; если относительное отклонение менее 20%, кандидат получает высокий вес.

<a id="2-7-spektralnye-metody-rezervnogo-poiska"></a>
### 2.7. Спектральные методы резервного поиска
1. **FFT**: классический метод, позволяющий быстро обнаружить основные пики. Подходит для сигналов с достаточной длиной и высоким отношением сигнал/шум.
2. **Авторегрессионная модель Бюрга**: строит AR-полином, устойчивый к коротким сигналам. Порядок модели выбирается из диапазона 6–12; по умолчанию используется 8.
3. **Метод Уэлча**: усреднённая периодограмма с перекрытием 50%, окно Хэмминга. Обеспечивает низкую дисперсию оценки.
4. **Усреднённый спектр**: усреднение спектров разных методов повышает устойчивость и снижает влияние отдельных неудачных оценок.
5. Для каждого метода вычисляется оценка амплитуды, частоты и при необходимости времени затухания.

<a id="2-8-nelinejnaya-minimizaciya-nevyazki"></a>
### 2.8. Нелинейная минимизация невязки
1. Используется `least_squares` с параметром `loss='linear'`. Возможны альтернативные функции потерь (например, `soft_l1`), но они не активированы по умолчанию.
2. Ограничения параметров передаются через аргументы `bounds=(lower, upper)`.
3. Шаги оптимизации масштабируются по нормам параметров, чтобы избежать плохой обусловленности.
4. Сходимость контролируется по норме градиента и по относительному изменению функции. Если за 200 итераций улучшение стоимости меньше 1e-9, процесс прекращается.
5. При расходимости оптимизатор перезапускается с уменьшенным шагом, но не более трёх попыток на комбинацию.

<a id="2-9-ocenka-doveritelnyh-intervalov"></a>
### 2.9. Оценка доверительных интервалов
1. После получения оптимальных параметров вычисляется матрица Якоби `J` (возвращается `least_squares`).
2. Ковариационная матрица `cov = σ^2 (J^T J)^{-1}`, где `σ^2 = cost / dof`, `dof = N - p`.
3. Стандартные отклонения `σ_f` и `σ_τ` переводятся в ГГц и наносекунды.
4. В отчётах отображаются интервалы `f ± σ_f` и `τ ± σ_τ`.
5. Если матрица `J^T J` плохо обусловлена, добавляется регуляризация `λI` с `λ = 1e-12`, что предотвращает численную нестабильность.

<a id="2-10-kriterii-kachestva-i-metriki-stoimosti"></a>
### 2.10. Критерии качества и метрики стоимости
1. Главная метрика — стоимость невязки. Низкая стоимость означает хорошее соответствие модели данным.
2. Дополнительные критерии:
   - Относительное отклонение от теории по частоте и времени затухания (<20%).
   - Соотношение амплитуд A1/A2 (не должно быть >100 или <0.01, иначе модель считается неустойчивой).
   - Доля объяснённой дисперсии `R²` (должна быть >0.9 для успешных случаев).
3. Эти значения выводятся в лог и в отчёты для последующего анализа.

---

<a id="glava-3-struktury-dannyh-i-formaty-fajlov"></a>
## Глава 3. Структуры данных и форматы файлов

<a id="3-1-syrye-zapisi-rawrecord"></a>
### 3.1. Сырые записи (`RawRecord`)
1. Атрибуты:
   - `path`: путь к файлу.
   - `field_mT`: значение магнитного поля в мТ.
   - `temp_K`: температура в К.
   - `band`: строка `'HF'` или `'LF'`.
   - `samples`: массив исходных значений (читается лениво).
2. Объект создаётся при сканировании файловой системы и хранится до формирования `DataSet`.
3. Метод `load()` возвращает времена и амплитуды в формате `numpy.ndarray`.

<a id="3-2-nabor-dannyh-dataset"></a>
### 3.2. Набор данных (`DataSet`)
1. Содержит всю информацию, необходимую для обработки одной пары LF/HF:
   - `field_mT`, `temp_K`.
   - `signal_lf`, `signal_hf`.
   - `fs_lf`, `fs_hf` — частоты дискретизации.
   - `dt_lf`, `dt_hf` — шаги по времени.
   - `freq_guess_lf`, `freq_guess_hf` — теоретические частоты (Гц).
   - `tau_guess_lf`, `tau_guess_hf` — теоретические времена затухания (сек).
   - `axis_kind`: `'H'` или `'T'`, указывает на тип теоретического файла.
2. Метод `has_both_bands()` сообщает, доступны ли LF и HF сигналы.
3. Методы `lf_time_vector()` и `hf_time_vector()` возвращают массив времени для визуализации и аппроксимации.
4. Метод `initial_window()` строит временной интервал, используемый для оценки амплитуд.

<a id="3-3-rezultaty-approksimacii-fittingresult"></a>
### 3.3. Результаты аппроксимации (`FittingResult`)
1. Поля результата:
   - `field_mT`, `temp_K`.
   - `f1_GHz`, `f2_GHz`.
   - `tau1_ns`, `tau2_ns`.
   - `amp1`, `amp2`.
   - `phase1`, `phase2`.
   - `offset`.
   - `cost`.
   - `success` (булево).
   - `source_lf`, `source_hf` (описание, откуда пришли лучшие кандидаты).
   - `sigma_f1`, `sigma_f2`, `sigma_tau1`, `sigma_tau2` — оценки ошибок.
2. Структура сериализуется в JSON/Excel для отчётности.

<a id="3-4-konfiguraciya-obrabotki-processingconfig"></a>
### 3.4. Конфигурация обработки (`ProcessingConfig`)
1. Параметры:
   - `lf_band = (4, 16)` ГГц.
   - `hf_band = (20, 40)` ГГц.
   - `tau_bounds = (1e-10, 5e-6)` сек.
   - `max_cost = 100`.
   - `model_rank = 4`.
   - `max_combinations = 25`.
   - `fft_expansions = 2`.
2. Конфигурация создаётся один раз в `cli.main` и передаётся в `process_pair`.

<a id="3-5-teoreticheskie-fajly-h-npy-i-t-npy"></a>
### 3.5. Теоретические файлы `H_*.npy` и `T_*.npy`
1. Структура файла: `arr.shape = (5, N)`.
2. Пример содержимого:
   - Строка 0: `[293, 298, 302, ...]` (температуры).
   - Строка 1: `[33.2, 32.8, ...]` (HF частоты, ГГц).
   - Строка 2: `[9.2, 9.3, ...]` (LF частоты, ГГц).
   - Строка 3: `[0.8, 0.75, ...]` (HF времена затухания, нс).
   - Строка 4: `[1.5, 1.6, ...]` (LF времена затухания, нс).
3. Программа автоматически выбирает элемент, ближайший к текущему полю/температуре.
4. Если массив содержит значения `NaN`, они игнорируются; система падает обратно на глобальные настройки.

<a id="3-6-eksportiruemye-tablicy"></a>
### 3.6. Экспортируемые таблицы
1. Таблицы Excel имеют одинаковое количество строк (температуры) и столбцов (поля).
2. Пустые ячейки обозначаются `NaN` и подсвечиваются в отчётах.
3. Лист `meta` содержит:
   - Версию ПО.
   - Дату и время запуска.
   - Имя пользователя (если доступно).
   - Границы диапазонов и параметры конфигурации.

---

<a id="glava-4-moduli-i-funkcii"></a>
## Глава 4. Модули и функции

<a id="4-1-modul-spectral-pipeline-init"></a>
### 4.1. Модуль `spectral_pipeline.__init__`
1. Определяет константы `GHZ`, `NS`, `PI`, `LF_BAND`, `HF_BAND`.
2. Содержит инициализацию логгера `logger`, настроенного на формат `'%(asctime)s [%(levelname)s] %(name)s: %(message)s'`.
3. Экспортирует классы `DataSet`, `FittingResult` и функции `load_records`, `process_pair`, `process_lf_only`.

<a id="4-2-modul-spectral-pipeline-cli"></a>
### 4.2. Модуль `spectral_pipeline.cli`
1. Функция `main(root: Path, export: bool, spectra: bool)` orchestrирует обработку.
2. Создаёт `ProcessingConfig`, вызывает `load_records`, затем запускает обработку каждой пары.
3. После получения результатов вызывает `visualize_stacked` или `visualize_without_spectra`.
4. При наличии флага `export` выполняет `export_freq_tables`.
5. Обрабатывает исключения, записывает их в лог и возвращает ненулевой код выхода.

<a id="4-3-modul-spectral-pipeline-io"></a>
### 4.3. Модуль `spectral_pipeline.io`
1. Функция `load_records` описана в разделе 1.3.
2. Вспомогательные функции:
   - `_parse_metadata_from_name` — извлекает поле и температуру из имени файла.
   - `_read_dat_file` — читает файлы формата `*.dat` с разделителем табуляция.
   - `_interpolate_signal` — выравнивает временные сетки LF/HF.
   - `_load_guess` — детально описана в разделе 1.5.
3. Модуль также содержит функцию `group_by_pair`, которая формирует словарь `{(field, temp): [records...]}`.

<a id="4-4-modul-spectral-pipeline-fit"></a>
### 4.4. Модуль `spectral_pipeline.fit`
1. Содержит основную логику ESPRIT, фильтрации, резервного поиска и аппроксимации (разделы 1.7–1.12).
2. Ключевые функции:
   - `_esprit_freqs_and_decay(signal, fs, rank, window)` — возвращает списки частот и времен затухания.
   - `_search_candidates(esprit_results, dataset, band)` — фильтрует кандидатов по диапазонам.
   - `_fallback_peak(signal, fs, band)` — выполняет резервный поиск пиков.
   - `_combine_candidates(lf_list, hf_list, theory)` — формирует комбинации.
   - `fit_pair(dataset, candidates)` — оптимизирует параметры модели.
   - `process_pair(dataset, config)` — обобщает все шаги для полной пары.
   - `process_lf_only(dataset, config)` — вариант для одиночного диапазона.
3. Вспомогательные функции: `burg`, `_fft_spectrum`, `_estimate_tau_from_time_domain`, `weighted_average`.
4. Все функции снабжены подробными докстрингами, описывающими единицы измерения и возможные исключения.

<a id="4-5-modul-spectral-pipeline-plotting"></a>
### 4.5. Модуль `spectral_pipeline.plotting`
1. Функция `visualize_stacked(results, spectra=True)` строит отчёт со спектрами.
2. Функция `visualize_without_spectra(results)` строит отчёт без спектров.
3. `_load_guess_curves` считывает теоретические кривые (частоты и времена затухания) для построения линий.
4. `_plot_frequency_panel`, `_plot_tau_panel`, `_plot_amplitude_panel` — отдельные функции для каждой панели графика.
5. `_format_axes` и `_annotate_success_ratio` настраивают внешний вид фигур, подписывают успехи/неудачи.
6. При генерации спектров используется `matplotlib.gridspec` с тремя строками и несколькими столбцами.

<a id="4-6-utilita-find-freqs-and-visualize-py"></a>
### 4.6. Утилита `find_freqs_and_visualize.py`
1. Простая обёртка над CLI для запуска из корня репозитория.
2. Обрабатывает аргументы командной строки через `argparse` и передаёт их в `spectral_pipeline.cli.main`.

---

<a id="glava-5-parametry-konstanty-i-konfiguraciya"></a>
## Глава 5. Параметры, константы и конфигурация

<a id="5-1-chastotnye-diapazony"></a>
### 5.1. Частотные диапазоны
1. LF диапазон: 4–16 ГГц. Настраивается через `ProcessingConfig.lf_band`.
2. HF диапазон: 20–40 ГГц. Настраивается через `ProcessingConfig.hf_band`.
3. При наличии теории диапазон сужается до `f_guess ± 5 ГГц`.
4. Минимально допустимый частотный шаг — 0.05 ГГц (используется для дискретизации сетки).

<a id="5-2-ogranicheniya-po-vremeni-zatuhaniya"></a>
### 5.2. Ограничения по времени затухания
1. Глобальные границы: `τ ∈ [1e-10, 5e-6]` секунд (0.1 нс – 5 мкс).
2. При наличии теории задаётся окно `τ_guess · (1 ± 0.2)`.
3. Минимальное относительное изменение при оптимизации — 1e-4.
4. При выходе τ за границы происходит перезапуск оптимизации с новыми кандидатами.

<a id="5-3-nastrojki-esprit"></a>
### 5.3. Настройки ESPRIT
1. Размер окна `NS = 64` точек.
2. Ранг модели `model_rank = 4`.
3. Используется комплексная арифметика двойной точности.
4. Регуляризация диагонали `ε = 1e-12`.
5. Количество компонент, возвращаемых функцией — до 8, но позднее ограничивается по диапазонам.

<a id="5-4-parametry-fft-i-okonnyh-funkcij"></a>
### 5.4. Параметры FFT и оконных функций
1. Окно: Хэмминга, но возможно переключение на Хэннинга или Блэкмана.
2. Целевая частотная сетка `df_target = 0.1 ГГц`.
3. Максимальное число расширений диапазона при поиске пиков — 2.
4. Пороговые множители `height` и `prominence` последовательно уменьшаются: 0.3 → 0.05 → 0.01.

<a id="5-5-parametry-approksimacii"></a>
### 5.5. Параметры аппроксимации
1. Максимальное число итераций оптимизатора — 200.
2. Толерансы: `ftol = 1e-12`, `xtol = 1e-12`, `gtol = 1e-12`.
3. Начальные амплитуды выбираются из линейной регрессии на первых 50 точках.
4. Фазы стартуют из `[−π/2, π/2]`.
5. Допустимое отклонение по стоимости между перезапусками — 1e-6.

<a id="5-6-nastrojki-vizualizacii"></a>
### 5.6. Настройки визуализации
1. Цветовая схема: LF — оттенки синего, HF — оттенки красного.
2. Толщина линий: теория 2.0, эксперимент 1.5.
3. Маркеры: кружки для экспериментальных точек, треугольники для теории.
4. Подписи осей на русском языке, формат чисел с одной значащей цифрой после запятой.
5. Времена затухания отображаются в наносекундах.

<a id="5-7-perechen-peremennyh-sredy"></a>
### 5.7. Перечень переменных среды
1. `PIPELINE_LOG_DIR` — путь к каталогу логов (по умолчанию `logs`).
2. `PIPELINE_OUTPUT_DIR` — путь к каталогу отчётов (по умолчанию `output`).
3. `PIPELINE_MAX_CORES` — ограничение на число потоков (если требуется).

---

<a id="glava-6-obrabotka-oshibok-i-diagnosticheskoe-logirovanie"></a>
## Глава 6. Обработка ошибок и диагностическое логирование

<a id="6-1-urovni-logirovaniya"></a>
### 6.1. Уровни логирования
1. `INFO` — основная информация о ходе обработки.
2. `DEBUG` — детальные сведения о промежуточных шагах (кандидаты, параметры оптимизации).
3. `WARNING` — ситуации, требующие внимания (нет пиков, комбинация за пределами диапазонов).
4. `ERROR` — критические ошибки (например, исключения в оптимизаторе).

<a id="6-2-osnovnye-soobscheniya-i-ih-interpretaciya"></a>
### 6.2. Основные сообщения и их интерпретация
1. `Загружено N наборов` — количество уникальных пар поле/температура.
2. `ESPRIT raw freqs` — массив частот, найденных ESPRIT до фильтрации.
3. `ESPRIT HF filtered` — список частот после применения диапазонов и условий по времени.
4. `FFT peak search` — диапазон, в котором производится поиск пиков.
5. `Peak near boundary` — предупреждение, что найденный пик находится рядом с границей, диапазон будет расширен.
6. `Начальные оценки` — параметры, с которых стартует оптимизация.
7. `Результат` — итог подгонки для конкретной комбинации.

<a id="6-3-diagnostika-neuspeshnyh-approksimacij"></a>
### 6.3. Диагностика неуспешных аппроксимаций
1. Если `cost > MAX_COST`, это говорит о плохом совпадении модели с экспериментом. Необходимо проверить теоретические данные или качество сигнала.
2. Сообщение `Комбинация вне freq_bounds` означает, что кандидат выходит за допустимые диапазоны. Следует уточнить теорию.
3. Предупреждение `в полосе X–Y ГГц пиков не найдено` свидетельствует о низком SNR или неверном диапазоне поиска.
4. При регулярных ошибках стоит увеличить `max_expansions` или снизить пороги поиска пиков.

<a id="6-4-otladka-esprit"></a>
### 6.4. Отладка ESPRIT
1. Лог `ESPRIT raw zeta` содержит значения `1/τ` (в сек^-1) до преобразования. Если присутствуют отрицательные числа, они будут отброшены.
2. При отсутствии кандидатов стоит проверить размер окна `NS` и ранжировку сингулярных значений.
3. Можно включить дополнительное логирование матриц `S` и `R`, чтобы проанализировать их обусловленность.

<a id="6-5-analiz-rezervnogo-poiska"></a>
### 6.5. Анализ резервного поиска
1. Сообщение `no peaks found, fallback to max` означает, что даже после расширения и снижения порогов явных максимумов нет; кандидат будет иметь низкий вес.
2. При появлении ложных пиков можно увеличить параметр `distance` в `find_peaks`.
3. Если Burg-оценка сильно расходится с FFT, стоит проверить стабильность AR-полинома.

---

<a id="glava-7-testirovanie-i-verifikaciya"></a>
## Глава 7. Тестирование и верификация

<a id="7-1-modulnye-testy"></a>
### 7.1. Модульные тесты
1. `tests/test_freq_bounds.py` проверяет, что частоты не выходят за диапазон и что окно расширяется корректно.
2. `tests/test_hf_filter_and_tau.py` убеждается, что отрицательные времена затухания фильтруются, а ограничения ±20% соблюдаются.
3. `tests/test_max_cost.py` гарантирует, что решения с высокой стоимостью отбрасываются.
4. `tests/test_success_count.py` проверяет корректность подсчёта успешных пар.
5. `tests/test_crossing.py` анализирует случаи пересечения теоретических кривых и обработку их в отчётах.

<a id="7-2-integracionnye-proverki"></a>
### 7.2. Интеграционные проверки
1. Скрипт `pytest` запускает все тесты.
2. Для реальных данных рекомендуется прогонять контрольные наборы и сравнивать результаты с эталонными Excel-файлами.
3. Проверяется корректность генерации отчётов и отсутствие выбросов за пределы диапазонов.

<a id="7-3-vosproizvodimost-rezultatov"></a>
### 7.3. Воспроизводимость результатов
1. Для воспроизводимости фиксируются константы и настройки.
2. Различия могут возникать из-за плавающих точек; рекомендуется сравнивать результаты с точностью до 1e-3.

<a id="7-4-metriki-proizvoditelnosti"></a>
### 7.4. Метрики производительности
1. Время обработки одной пары зависит от длины сигналов: для 1000 точек — порядка 0.5 секунды.
2. ESPRIT занимает около 30% времени, оптимизация — 50%, визуализация — 20%.
3. При необходимости можно распараллелить обработку по полям/температурам.

---

<a id="glava-8-rukovodstvo-polzovatelya"></a>
## Глава 8. Руководство пользователя

<a id="8-1-podgotovka-dannyh"></a>
### 8.1. Подготовка данных
1. Сохраните пары файлов HF/LF в каталоге `data`.
2. Убедитесь, что имена файлов содержат параметры поля и температуры.
3. При наличии теории разместите файлы `H_<field>.npy` и/или `T_<temp>.npy` в корне данных.
4. Если сигналы нуждаются в предварительной фильтрации, выполните её до запуска программы.

<a id="8-2-scenarii-zapuska"></a>
### 8.2. Сценарии запуска
1. Стандартный запуск с визуализацией и экспортом: `python find_freqs_and_visualize.py --root . --export`.
2. Быстрая проверка без спектров: `python find_freqs_and_visualize.py --root . --no-spectra`.
3. Сборка отчётов по одному полю: можно отфильтровать данные в `data` и запустить скрипт повторно.

<a id="8-3-nastrojka-parametrov-obrabotki"></a>
### 8.3. Настройка параметров обработки
1. Измените `ProcessingConfig` в `spectral_pipeline/cli.py`, чтобы скорректировать диапазоны и ограничения.
2. Для тонкой настройки ESPRIT и FFT измените параметры в `spectral_pipeline/fit.py` (`NS`, `model_rank`, `df_target` и т.д.).
3. Визуализация настраивается через аргументы функций в `plotting.py` (цвета, форматы, размеры).

<a id="8-4-analiz-otchetov-i-grafikov"></a>
### 8.4. Анализ отчётов и графиков
1. На графиках частот и времен затухания синяя линия соответствует LF, красная — HF.
2. Теоретические значения отображаются пунктиром; экспериментальные точки — кружками.
3. Ошибки отображаются вертикальными отрезками (если рассчитаны).
4. В таблицах Excel строки соответствуют температурам, столбцы — полям.

<a id="8-5-tipovye-problemy-i-resheniya"></a>
### 8.5. Типовые проблемы и решения
1. **Нет пиков в HF диапазоне**: проверьте корректность теории, увеличьте окно поиска.
2. **Высокая стоимость**: возможно, теоретические значения устарели; обновите файлы `H_*.npy` и `T_*.npy`.
3. **Нестабильная аппроксимация**: уменьшите `max_combinations` или расширьте диапазон τ.
4. **Отсутствие отчётов**: убедитесь, что каталог `output` доступен для записи.

---

<a id="glava-9-vnutrennie-soglasheniya-i-stil-koda"></a>
## Глава 9. Внутренние соглашения и стиль кода

<a id="9-1-imenovanie"></a>
### 9.1. Именование
1. Переменные с суффиксом `_GHz` хранят частоты в ГГц, `_Hz` — в Гц, `_ns` — в наносекундах.
2. Функции и методы используют глагольные формы (`load`, `process`, `fit`).
3. Классы именуются в стиле CamelCase (`DataSet`, `FittingResult`).

<a id="9-2-standarty-dokumentirovaniya"></a>
### 9.2. Стандарты документирования
1. Все функции снабжены докстрингами на русском языке.
2. Докстринги описывают типы параметров, единицы измерения и возможные исключения.
3. Внутренние комментарии поясняют ключевые математические шаги.

<a id="9-3-obrabotka-chislennyh-oshibok"></a>
### 9.3. Обработка численных ошибок
1. Перед делением проверяются знаменатели, добавляется `1e-16` при необходимости.
2. При логарифмировании модулей проверяется, что аргумент положителен.
3. Используются функции `np.nan_to_num` для подавления `NaN`.

<a id="9-4-rabota-s-edinicami-izmereniya"></a>
### 9.4. Работа с единицами измерения
1. Все входные данные переводятся в систему SI.
2. Отображение результатов осуществляется в удобных единицах (ГГц и нс).
3. Конвертация выполняется централизованно в `__init__.py`, чтобы избежать ошибок.

<a id="9-5-podderzhka-rasshirenij-i-modifikacij"></a>
### 9.5. Поддержка расширений и модификаций
1. Код организован по модулям, что облегчает добавление новых методов анализа.
2. Расширение до трёх или более мод возможно через изменение размерности в ESPRIT и оптимизаторе.
3. Для поддержки новых форматов теории необходимо обновить `_load_guess` и `_load_guess_curves`.

---

<a id="glava-10-prilozheniya"></a>
## Глава 10. Приложения

<a id="10-1-prilozhenie-a-podrobnyj-primer-obrabotki-odnoj-pary"></a>
### 10.1. Приложение A. Подробный пример обработки одной пары
1. Исходные данные: поле 100 мТ, температура 293 К.
2. Загружаются файлы `..._HF_...dat` и `..._LF_...dat`.
3. Теоретический файл `H_100.npy` содержит значения `f_hf = 32.9 ГГц`, `f_lf = 9.3 ГГц`, `τ_hf = 0.8 нс`, `τ_lf = 1.6 нс`.
4. ESPRIT выдаёт кандидатов: LF {10.2 ГГц, 1.5 нс}, HF {25.1 ГГц, 0.7 нс}.
5. После фильтрации остаются LF {9.3, 1.6}, HF {32.9, 0.8}.
6. FFT подтверждает наличие пиков 8.2 и 33.0 ГГц.
7. В оптимизатор передаётся комбинация (9.3, 32.9) с временами (1.6, 0.8).
8. Нелинейная подгонка возвращает `f1 = 9.01 ГГц`, `f2 = 30.57 ГГц`, `τ1 = 1.52 нс`, `τ2 = 0.78 нс`, `cost = 80.77`.
9. Решение удовлетворяет критериям и сохраняется.

<a id="10-2-prilozhenie-b-tablicy-parametrov-i-postoyannyh"></a>
### 10.2. Приложение B. Таблицы параметров и постоянных
| Константа | Значение | Описание |
|-----------|----------|----------|
| `GHZ` | `1e9` | Перевод ГГц → Гц |
| `NS` | `1e-9` | Перевод нс → с |
| `LF_BAND` | `(4, 16)` | Диапазон частот LF |
| `HF_BAND` | `(20, 40)` | Диапазон частот HF |
| `MAX_COST` | `100` | Максимально допустимая стоимость |

<a id="10-3-prilozhenie-c-format-logov"></a>
### 10.3. Приложение C. Формат логов
1. Формат строки: `YYYY-MM-DD HH:MM:SS [LEVEL] logger: сообщение`.
2. Примеры сообщений приведены в разделе 6.2.
3. Логи сохраняются в `logs/pipeline.log` и обновляются при каждом запуске.

<a id="10-4-prilozhenie-d-psevdokod-klyuchevyh-algoritmov"></a>
### 10.4. Приложение D. Псевдокод ключевых алгоритмов
```
process_pair(dataset):
    esprit_lf, esprit_hf = _esprit_freqs_and_decay(dataset)
    candidates_lf = _search_candidates(esprit_lf, dataset.lf)
    candidates_hf = _search_candidates(esprit_hf, dataset.hf)
    if not candidates_lf: candidates_lf += _fallback_peak(dataset.lf)
    if not candidates_hf: candidates_hf += _fallback_peak(dataset.hf)
    combinations = _combine_candidates(candidates_lf, candidates_hf)
    best = None
    for combo in combinations:
        result = fit_pair(dataset, combo)
        if result.success and result.cost < best.cost:
            best = result
    return best
```

<a id="10-5-prilozhenie-e-spisok-ispolzuemyh-sokraschenij"></a>
### 10.5. Приложение E. Список используемых сокращений
- LF — Low Frequency.
- HF — High Frequency.
- τ — время затухания.
- ESPRIT — Estimation of Signal Parameters via Rotational Invariance Techniques.
- FFT — Fast Fourier Transform.
- AR — AutoRegressive.
- SVD — Singular Value Decomposition.

<a id="10-6-prilozhenie-f-plan-rasshireniya-funkcionalnosti"></a>
### 10.6. Приложение F. План расширения функциональности
1. Поддержка дополнительных диапазонов (MF, VF).
2. Интеграция с базой данных для хранения результатов.
3. Добавление Bayesian-аппроксимации с априорной информацией о распределениях.
4. Реализация веб-интерфейса для интерактивного анализа.

---


<a id="glava-11-detalnaya-dekompoziciya-funkcij"></a>
## Глава 11. Детальная декомпозиция функций

<a id="11-1-spectral-pipeline-cli-main"></a>
### 11.1. `spectral_pipeline.cli.main`
1. **Получение аргументов**: функция принимает путь `root`, булевы флаги `export` и `spectra`, а также произвольные параметры конфигурации.
2. **Инициализация логирования**: устанавливается уровень логирования в соответствии с аргументом `log_level`.
3. **Создание конфигурации**: вызывается `ProcessingConfig()`, который считывает значения по умолчанию и подготавливает диапазоны LF/HF.
4. **Загрузка записей**: функция `load_records(root / "data")` возвращает список `DataSet`. В лог `INFO` выводится количество найденных файлов.
5. **Обработка каждой пары**:
   - Для каждой записи проверяется наличие LF и HF сигналов.
   - В зависимости от результата вызывается `process_pair` или `process_lf_only`.
   - Результаты добавляются в список, одновременно ведётся счётчик успешных обработок.
6. **Обработка исключений**: любые необработанные ошибки перехватываются, записываются в лог уровня `ERROR` и завершают программу с ненулевым кодом.
7. **Генерация отчётов**: на основании аргумента `spectra` выбирается функция визуализации.
8. **Экспорт**: если `export=True`, вызывается `export_freq_tables`.
9. **Возврат**: функция возвращает список `FittingResult` и словарь метаданных.

<a id="11-2-spectral-pipeline-io-load-records"></a>
### 11.2. `spectral_pipeline.io.load_records`
1. **Перечисление файлов**: используется `Path.glob('*.dat')` для поиска всех файлов.
2. **Группировка**: словарь `defaultdict(list)` группирует записи по ключу `(field_mT, temp_K)`.
3. **Создание RawRecord**: для каждого файла извлекается диапазон (HF/LF) и создаётся объект `RawRecord`.
4. **Сборка DataSet**:
   - Выделяются пары LF/HF.
   - Если один из диапазонов отсутствует, создаётся неполный `DataSet`.
   - На этапе создания выполняется чтение данных, нормализация, загрузка теории.
5. **Проверка целостности**: если нет ни одного полного набора, выводится предупреждение и возвращается пустой список.
6. **Возврат**: функция возвращает список `DataSet` и метаданные о диапазоне температур и полей.

<a id="11-3-load-guess"></a>
### 11.3. `_load_guess`
1. **Выбор файла**: предпочтение отдаётся `H_<field>.npy`, так как он привязан к магнитному полю. Если отсутствует, используется `T_<temp>.npy`.
2. **Загрузка массива**: применяется `np.load`. В случае ошибки логируется предупреждение и функция возвращает `None`.
3. **Проверка формы**: ожидается минимум 3 строки. Если строк меньше, данные считаются неполными.
4. **Извлечение значений**:
   - Строка 0 — ось (поле или температура).
   - Строка 1 — частоты HF (ГГц).
   - Строка 2 — частоты LF (ГГц).
   - Строка 3 — времена затухания HF (нс).
   - Строка 4 — времена затухания LF (нс).
5. **Поиск ближайшего индекса**: `idx = argmin(|axis - axis_value|)`.
6. **Преобразование единиц**: `f_lf = lf[idx] * GHZ`, `f_hf = hf[idx] * GHZ`, `τ_lf = tau_lf[idx] * NS`, `τ_hf = tau_hf[idx] * NS`.
7. **Формирование результата**: возвращается кортеж `(f_lf_Hz, f_hf_Hz, τ_lf_s, τ_hf_s)`.

<a id="11-4-esprit-freqs-and-decay"></a>
### 11.4. `_esprit_freqs_and_decay`
1. **Подготовка данных**: сигнал центрируется, при необходимости умножается на окно.
2. **Формирование матриц**:
   - `X0` и `X1` формируются сдвигом.
   - Рассчитываются корреляционные матрицы `S` и `R`.
3. **Регуляризация**: к диагонали `S` добавляется `εI`, чтобы предотвратить вырождение.
4. **SVD**: выполняется `scipy.linalg.svd` для `S`, выбираются первые `model_rank` компонент.
5. **Решение задачи собственных значений**: вычисляется `scipy.linalg.eig(R_sub, S_sub)`.
6. **Преобразование собственных значений**: полученные λ переводятся в частоты и времена затухания.
7. **Фильтрация**: значения с `τ <= 0` или `|f|` вне диапазона отбрасываются.
8. **Возврат**: список словарей с полями `frequency_GHz`, `tau_ns`, `source='ESPRIT'`, `weight=0.7`.

<a id="11-5-search-candidates"></a>
### 11.5. `_search_candidates`
1. **Разделение по диапазонам**: массив ESPRIT разбивается на LF и HF по сравнениям с `lf_band` и `hf_band`.
2. **Учет теории**: если `dataset.tau_guess_*` доступны, устанавливаются интервалы для `f` и `τ`.
3. **Расширение HF окна**: при отсутствии кандидатов окно расширяется до `±10 ГГц` и фильтрация повторяется.
4. **Добавление теоретических значений**: независимо от ESPRIT, теоретические частоты и времена добавляются в список с весом 1.0.
5. **Добавление FFT пиков**: если были найдены в `_fallback_peak`, они объединяются со списком.
6. **Сортировка и обрезка**: список сортируется по весу и отклонению, оставляется не более `max_candidates` (обычно 5).

<a id="11-6-fallback-peak"></a>
### 11.6. `_fallback_peak`
1. **FFT**: вызывается `_fft_spectrum`, возвращающая частоты и амплитуды.
2. **Поиск пиков**: `find_peaks` вызывается с последовательностью порогов. Логи уровня `DEBUG` отображают параметры поиска.
3. **Проверка границ**: если пик ближе 5% ширины диапазона, выполняется расширение.
4. **Burg-AR**: в отсутствие пиков строится AR-модель, корни полинома дают частоты-кандидаты.
5. **Метод Уэлча**: вычисляет усреднённый спектр, используется как дополнительный источник.
6. **Оценка времени**: функция `_estimate_tau_from_time_domain` анализирует логарифм огибающей и возвращает оценку τ.
7. **Возврат**: список кандидатов с указанием источника (`FFT`, `Burg`, `Welch`).

<a id="11-7-fit-pair"></a>
### 11.7. `fit_pair`
1. **Формирование начального параметра**: на основе кандидатов задаются `f`, `τ`, `A`, `φ`, `C`.
2. **Подготовка временных массивов**: функции `lf_time_vector` и `hf_time_vector` возвращают `t` для LF и HF.
3. **Функция модели**: внутри `residuals` формируется сигнал модели и вычитается из измеренного.
4. **Веса**: применяются веса `exp(-t / τ_weight)`, где `τ_weight` пропорционален длительности записи.
5. **Вызов оптимизатора**: `least_squares` с границами.
6. **Анализ результата**: проверяются условия успеха, вычисляются ошибки, формируется `FittingResult`.

<a id="11-8-process-pair"></a>
### 11.8. `process_pair`
1. **ESPRIT**: получение кандидатов.
2. **Фильтрация**: применение `_search_candidates`.
3. **Добавление резервных кандидатов**: вызов `_fallback_peak` при необходимости.
4. **Комбинации**: генерация и сортировка комбинаций по априорным весам.
5. **Аппроксимация**: вызов `fit_pair` для каждой комбинации.
6. **Выбор лучшего**: по минимальной стоимости и дополнительным критериям.
7. **Логирование**: подробные сообщения с параметрами.
8. **Возврат**: объект `FittingResult`.

<a id="11-9-process-lf-only"></a>
### 11.9. `process_lf_only`
1. **Теория**: учитывает только LF значения.
2. **ESPRIT**: получение LF кандидатов.
3. **Резервный поиск**: FFT, Burg, Welch.
4. **Аппроксимация**: однотональная модель.
5. **Формирование результата**: HF поля устанавливаются в `NaN`.

<a id="11-10-export-freq-tables"></a>
### 11.10. `export_freq_tables`
1. **Подготовка DataFrame**: создаются четыре таблицы для частот и времен.
2. **Заполнение**: используется `pivot_table` по полю и температуре.
3. **Форматирование**: значения округляются до сотых.
4. **Сохранение**: `pandas.ExcelWriter` с движком `openpyxl`.
5. **Метаданные**: создаётся лист `meta` с параметрами запуска.

<a id="glava-12-dopolnitelnye-scenarii-i-prakticheskie-rekomendacii"></a>
## Глава 12. Дополнительные сценарии и практические рекомендации

<a id="12-1-nastrojka-esprit-pod-shumnye-dannye"></a>
### 12.1. Настройка ESPRIT под шумные данные
1. Увеличьте `NS` до 96 или 128, чтобы увеличить устойчивость к шуму.
2. Повышенный `model_rank` (до 6) позволяет уловить дополнительные моды и затем отфильтровать их.
3. Добавьте регуляризацию к `S` в виде `εI` с `ε = 1e-10` при сильном шуме.
4. Используйте усреднение нескольких запусков ESPRIT с перекрывающимися окнами.

<a id="12-2-rabota-s-korotkimi-signalami"></a>
### 12.2. Работа с короткими сигналами
1. Для коротких сигналов уменьшите `NS` до 32, чтобы получить больше сегментов.
2. Увеличьте порядок AR-модели в `_fallback_peak`, поскольку FFT может быть грубым.
3. Расширьте диапазон `τ` до `[1e-11, 1e-6]` для лучшей гибкости.

<a id="12-3-podderzhka-dopolnitelnyh-diapazonov"></a>
### 12.3. Поддержка дополнительных диапазонов
1. Добавьте новые константы `MF_BAND`, `VF_BAND` в `__init__.py`.
2. Расширьте `ProcessingConfig`, чтобы включить новые диапазоны.
3. Обновите `plotting.py`, добавив дополнительные панели.
4. Измените `export_freq_tables`, чтобы создавать дополнительные листы.

<a id="12-4-ispolzovanie-polzovatelskih-okonnyh-funkcij"></a>
### 12.4. Использование пользовательских оконных функций
1. Передайте параметр `window_name` в `_fft_spectrum` (`hann`, `blackman` и т.д.).
2. Проверьте, что выбранное окно доступно в `scipy.signal.get_window`.
3. Согласуйте корректирующий множитель `win_sum_sq`.

<a id="12-5-rabota-v-paketnom-rezhime"></a>
### 12.5. Работа в пакетном режиме
1. Напишите оболочку, которая запускает `find_freqs_and_visualize.py` для нескольких каталогов подряд.
2. Используйте параметр `PIPELINE_OUTPUT_DIR`, чтобы сохранять отчёты в отдельные папки.
3. Ведите журнал запусков для анализа результатов.

<a id="glava-13-rasshirennye-dannye-o-vizualizacii"></a>
## Глава 13. Расширенные данные о визуализации

<a id="13-1-struktura-figur-v-visualize-stacked"></a>
### 13.1. Структура фигур в `visualize_stacked`
1. Используется `matplotlib.gridspec.GridSpec` с тремя строками и четырьмя столбцами.
2. Первая колонка содержит спектры HF и LF, объединённые вертикально.
3. Остальные три колонки отображают частоты, времена затухания и амплитуды.
4. В каждой панели отображаются экспериментальные точки и теоретические линии.

<a id="13-2-podgotovka-dannyh-dlya-grafikov"></a>
### 13.2. Подготовка данных для графиков
1. Из `FittingResult` извлекаются значения `f1`, `f2`, `τ1`, `τ2`, `A1`, `A2`.
2. Для каждой температуры строится словарь `{field: value}` для быстрого заполнения сетки.
3. Теоретические кривые загружаются через `_load_guess_curves` и интерполируются линейно.
4. Визуализация учитывает успешность аппроксимации: неуспешные точки отображаются пустыми маркерами.

<a id="13-3-nastrojka-podpisej-i-legend"></a>
### 13.3. Настройка подписей и легенд
1. Заголовок каждой фигуры формируется шаблоном `T=<temp>K` или `H=<field>mT`.
2. Легенды разделяются на «Эксперимент» и «Теория».
3. В нижней части фигуры выводится сводка: количество успешных пар, средняя стоимость, дата обработки.
4. Используются подписи осей: `Частота, ГГц`, `Время затухания, нс`, `Амплитуда, отн. ед.`

<a id="13-4-rabota-s-masshtabami-osej"></a>
### 13.4. Работа с масштабами осей
1. Частоты отображаются в диапазоне 0–40 ГГц.
2. Времена затухания — в диапазоне 0–5 нс, но масштаб может автоматически расширяться при необходимости.
3. Амплитуды отображаются в диапазоне, рассчитанном на основе максимального значения среди всех точек.
4. При логарифмической шкале (опционально) используется `ax.set_yscale('log')`.

<a id="glava-14-polnyj-perechen-log-soobschenij"></a>
## Глава 14. Полный перечень лог-сообщений

<a id="14-1-soobscheniya-urovnya-info"></a>
### 14.1. Сообщения уровня INFO
1. `Начало обработки каталога ...`
2. `Поиск данных в ...`
3. `Загружен <filename>: <N> точек, fs=<value>`
4. `Загружено <N> наборов`
5. `Обработка пары T=<temp> K, H=<field> mT`
6. `Total expansions: <n>, final range <a>–<b> ГГц`
7. `Аппроксимация успешна f1=<..> ГГц, f2=<..> ГГц, cost=<..>`

<a id="14-2-soobscheniya-urovnya-warning"></a>
### 14.2. Сообщения уровня WARNING
1. `в полосе X–Y ГГц пиков не найдено`
2. `Комбинация вне freq_bounds`
3. `вызван fallback для LF`
4. `Peak near boundary even after <n> expansions`

<a id="14-3-soobscheniya-urovnya-debug"></a>
### 14.3. Сообщения уровня DEBUG
1. `ESPRIT raw freqs: [...]`
2. `ESPRIT raw zeta: [...]`
3. `ESPRIT HF filtered: [...]`
4. `find_peaks: height>=..., prom>=... -> <n> peaks`
5. `Начальные оценки: f1=..., f2=...`
6. `Результат: f1=...±..., f2=...±..., cost=...`

<a id="14-4-soobscheniya-urovnya-error"></a>
### 14.4. Сообщения уровня ERROR
1. `Ошибка обработки (H, T): <сообщение>` — обычно связано с отсутствующим модулем или неверными данными.
2. `Не удалось загрузить <файл>: <исключение>` — проблемы с чтением теории.

<a id="glava-15-kontrol-kachestva-dannyh"></a>
## Глава 15. Контроль качества данных

<a id="15-1-proverka-vhodnyh-signalov"></a>
### 15.1. Проверка входных сигналов
1. Сигнал не должен содержать `NaN` или `Inf`.
2. Максимальное отклонение от среднего не должно превышать 10 (после нормализации).
3. При наличии скачков рекомендуется предварительная фильтрация (например, медианная).

<a id="15-2-proverka-teoreticheskih-fajlov"></a>
### 15.2. Проверка теоретических файлов
1. Убедитесь, что строки 1–4 не содержат пропусков.
2. Если значения времени затухания равны нулю, аппроксимация может стать неустойчивой; замените их на небольшое положительное число.
3. Согласуйте единицы измерения: частоты — ГГц, времена — нс.

<a id="15-3-proverka-rezultatov"></a>
### 15.3. Проверка результатов
1. Сравните найденные частоты с теорией: относительное отклонение должно быть менее 20%.
2. Проверьте стоимость: значения >100 требуют внимания.
3. Убедитесь, что графики не содержат резких выбросов.

<a id="prilozhenie-g-rasshirennaya-tablica-parametrov-funkcij"></a>
## Приложение G. Расширенная таблица параметров функций
| Функция | Аргументы | Возвращаемое значение | Исключения | Логирование |
|---------|-----------|------------------------|------------|-------------|
| `main` | `root`, `export`, `spectra` | Список `FittingResult` | `FileNotFoundError`, `RuntimeError` | INFO, ERROR |
| `load_records` | `path` | `list[DataSet]` | `ValueError` | INFO, WARNING |
| `_load_guess` | `directory`, `field`, `temp` | Кортеж значений | `IOError` | WARNING |
| `_esprit_freqs_and_decay` | `signal`, `fs` | Список кандидатов | `LinAlgError` | DEBUG |
| `_search_candidates` | `candidates`, `dataset` | Отфильтрованный список | — | DEBUG |
| `_fallback_peak` | `signal`, `fs`, `band` | Список кандидатов | — | INFO, DEBUG |
| `fit_pair` | `dataset`, `combo` | `FittingResult` | `RuntimeError` | DEBUG |
| `process_pair` | `dataset`, `config` | `FittingResult` | — | INFO, DEBUG |
| `process_lf_only` | `dataset`, `config` | `FittingResult` | — | INFO, DEBUG |
| `export_freq_tables` | `results`, `path` | Путь к файлу | `IOError` | INFO |

<a id="prilozhenie-h-poshagovaya-proverka-posle-obnovleniya-koda"></a>
## Приложение H. Пошаговая проверка после обновления кода
1. Выполните `pytest` и убедитесь, что все тесты проходят.
2. Запустите обработку контрольного набора данных и сравните результаты с эталонными.
3. Проверьте Excel-файл: убедитесь, что новые листы `LF_tau_ns` и `HF_tau_ns` присутствуют.
4. Откройте отчёты и убедитесь, что графики времени затухания отображаются корректно.
5. Просмотрите лог `pipeline.log` на предмет новых предупреждений.

<a id="prilozhenie-i-svodnaya-tablica-edinic-izmereniya"></a>
## Приложение I. Сводная таблица единиц измерения
| Величина | Внутренняя единица | Внешняя единица | Комментарий |
|----------|--------------------|------------------|-------------|
| Частота | Гц | ГГц | Для отображения используется деление на `GHZ`. |
| Время | секунды | наносекунды | Для отображения используется деление на `NS`. |
| Амплитуда | Отн. единицы | Отн. единицы | Нормирована на RMS. |
| Стоимость | Безразмерная | Безразмерная | 0.5 * сумма квадратов невязок. |

<a id="prilozhenie-j-glossarij-terminov"></a>
## Приложение J. Глоссарий терминов
1. **Корреляционная матрица** — матрица, составленная из попарных скалярных произведений сегментов сигнала, используемая в ESPRIT.
2. **Комбинация кандидатов** — пара `(LF, HF)`, выбранная для последующей аппроксимации.
3. **Время затухания** — характеристика, определяющая скорость экспоненциального спада амплитуды.
4. **Стоимость (cost)** — значение функции невязки, используемое для ранжирования решений.
5. **ESPRIT** — метод оценки частот и затуханий с использованием сдвиговой инвариантности сигналов.

<a id="prilozhenie-k-rekomendacii-po-adaptacii-k-novym-eksperimentam"></a>
## Приложение K. Рекомендации по адаптации к новым экспериментам
1. Если эксперимент включает больше мод, увеличьте `model_rank` и адаптируйте структуру `FittingResult`.
2. Для временных рядов с неравномерной дискретизацией используйте интерполяцию на равномерную сетку перед анализом.
3. При наличии шумов с тенденцией к дрейфу добавьте процедуру удаления тренда (например, полиномиальная регрессия).
4. Для экспериментов с переменным числом точек примените выравнивание через `scipy.interpolate.interp1d`.


<a id="prilozhenie-l-detalnoe-opisanie-parametrov-optimizatora"></a>
## Приложение L. Детальное описание параметров оптимизатора
1. `method='trf'` — метод доверительной области с отражением границ.
2. `loss='linear'` — классическая квадратичная функция потерь.
3. `ftol=1e-12` — условие остановки по изменению функции.
4. `xtol=1e-12` — условие остановки по изменению параметров.
5. `gtol=1e-12` — условие остановки по норме градиента.
6. `max_nfev=200` — ограничение на число вычислений функции.
7. `jac='2-point'` — численное вычисление Якобиана с центральной разностью.
8. `x_scale='jac'` — масштабирование параметров по Якобиану.
9. `tr_solver='lsmr'` — решатель для задачи наименьших квадратов в доверительной области.
10. `verbose=0` — отсутствие вывода от оптимизатора (логирование ведётся вручную).

<a id="prilozhenie-m-hronologiya-obrabotki-odnoj-pary-rasshirennaya"></a>
## Приложение M. Хронология обработки одной пары (расширенная)
1. Запись о начале обработки пары.
2. Загрузка LF и HF сигналов.
3. Проверка наличия теоретического файла `H_<field>.npy`.
4. При отсутствии — попытка загрузить `T_<temp>.npy`.
5. Конвертация теоретических частот и времен в SI.
6. Нормализация LF сигнала.
7. Нормализация HF сигнала.
8. Расчёт временных шагов `dt`.
9. Формирование временных массивов.
10. Применение оконных функций.
11. Построение корреляционных матриц для LF.
12. Выполнение SVD для LF.
13. Решение задачи собственных значений для LF.
14. Преобразование собственных значений в частоты LF.
15. Преобразование собственных значений в времена LF.
16. Аналогичные шаги для HF.
17. Объединение результатов ESPRIT.
18. Фильтрация LF кандидатов по диапазону.
19. Фильтрация HF кандидатов по диапазону.
20. Сравнение кандидатов с теорией.
21. Расширение HF диапазона при отсутствии кандидатов.
22. Повторная фильтрация HF после расширения.
23. Запуск FFT для LF.
24. Поиск пиков LF методом `find_peaks`.
25. Проверка границ для LF пиков.
26. Запуск FFT для HF.
27. Поиск пиков HF методом `find_peaks`.
28. Расширение HF диапазона при необходимости.
29. Применение метода Бюрга для LF.
30. Применение метода Бюрга для HF.
31. Применение метода Уэлча для LF.
32. Применение метода Уэлча для HF.
33. Расчёт времён затухания для кандидатов FFT/AR.
34. Объединение кандидатов LF.
35. Объединение кандидатов HF.
36. Добавление теоретических точек в списки кандидатов.
37. Сортировка кандидатов LF.
38. Сортировка кандидатов HF.
39. Ограничение числа кандидатов LF.
40. Ограничение числа кандидатов HF.
41. Генерация всех комбинаций `LF × HF`.
42. Применение дополнительных критериев фильтрации комбинаций.
43. Подготовка начальных параметров для первой комбинации.
44. Запуск оптимизатора для комбинации №1.
45. Анализ результата комбинации №1.
46. Повторные запуски оптимизатора при необходимости.
47. Переход к следующей комбинации.
48. Повторение шагов 44–46 для каждой комбинации.
49. Выбор комбинации с минимальной стоимостью.
50. Проверка отклонения от теории для выбранной комбинации.
51. Расчёт статистик и ошибок.
52. Формирование объекта `FittingResult`.
53. Запись результата в общий список.
54. Обновление счётчика успешных случаев.
55. Передача результата в модуль визуализации.
56. Обновление таблиц для экспорта.
57. Печать сообщения `аппроксимация успешна` или предупреждения.
58. Переход к следующей паре.

<a id="prilozhenie-n-primery-strok-logov-i-ih-traktovka"></a>
## Приложение N. Примеры строк логов и их трактовка
1. `2025-09-09 20:28:17 [DEBUG] spectral_pipeline: ESPRIT raw freqs: [...]` — исходные частоты, до фильтрации.
2. `2025-09-09 20:28:17 [DEBUG] spectral_pipeline: ESPRIT HF filtered: []` — после фильтрации HF кандидатов не осталось.
3. `2025-09-09 20:28:17 [INFO] spectral_pipeline: FFT peak search: 27.9–37.9 ГГц` — выполняется резервный поиск.
4. `2025-09-09 20:28:17 [WARNING] spectral_pipeline: в полосе 28–38 ГГц пиков не найдено` — FFT не нашла подходящих пиков.
5. `2025-09-09 20:28:17 [DEBUG] spectral_pipeline: no peaks found, fallback to max: f=27.999 ГГц, amp=4.15e-06` — используется максимальная точка спектра.
6. `2025-09-09 20:28:17 [DEBUG] spectral_pipeline: Комбинация вне freq_bounds: f1=10.199 ГГц, f2=25.107 ГГц` — комбинация отклонена, поскольку частоты выходят за диапазон.
7. `2025-09-09 20:28:18 [DEBUG] spectral_pipeline: Результат: f1=9.017±0.039 ГГц, f2=30.575±0.376 ГГц, cost=8.077e+01` — успешная аппроксимация.
8. `2025-09-09 20:28:23 [INFO] spectral_pipeline: Таблицы сохранены в ...` — экспорт завершён.

<a id="prilozhenie-o-algoritm-ocenki-vremen-zatuhaniya-po-vremennoj-oblasti"></a>
## Приложение O. Алгоритм оценки времен затухания по временной области
1. Преобразование сигнала в огибающую через `np.abs(hilbert(signal))`.
2. Логарифмирование огибающей: `log_env = np.log(env + 1e-16)`.
3. Выбор окна первых `M` точек (обычно `M = len(signal) // 3`).
4. Выполнение линейной регрессии `log_env ≈ a t + b`.
5. Оценка времени затухания как `τ = -1/a`.
6. Ограничение `τ` диапазоном `[τ_min, τ_max]`.
7. Возврат результата в наносекундах.

<a id="prilozhenie-p-kontrolnaya-tablica-dopustimyh-otklonenij"></a>
## Приложение P. Контрольная таблица допустимых отклонений
| Параметр | Относительное отклонение | Действия при превышении |
|----------|--------------------------|-------------------------|
| Частота LF | 20% | Проверить теорию, расширить диапазон LF |
| Частота HF | 20% | Проверить данные, увеличить `max_expansions` |
| Время LF | 20% | Пересмотреть оценку τ, проверить сигнал на шум |
| Время HF | 20% | Проверить окно анализа, оценить качество спектра |
| Амплитуда | 100% | Убедиться в корректной нормализации |

<a id="prilozhenie-q-diagnostika-artefaktov-v-spektrah"></a>
## Приложение Q. Диагностика артефактов в спектрах
1. **Зазубрины**: возникают из-за недостаточного окна — используйте более гладкую оконную функцию.
2. **Боковые лепестки**: признак слишком короткого сигнала — увеличьте длину или примените нулевое дополнение.
3. **Рябь**: может быть следствием несовпадения частот — уточните частотную сетку.
4. **Шумовой пол**: высокий уровень шума — примените дополнительное сглаживание или фильтрацию во временной области.

<a id="prilozhenie-r-poshagovaya-nastrojka-vizualizacii-bez-spektra"></a>
## Приложение R. Пошаговая настройка визуализации без спектра
1. Отключите флаг `spectra` при запуске CLI.
2. Убедитесь, что функции `visualize_without_spectra` получают список `FittingResult`.
3. Проверяйте, что панели частоты, времени и амплитуды отображаются корректно.
4. В легендах должны присутствовать подписи «Эксперимент» и «Теория».
5. График времени затухания должен располагаться между частотой и амплитудой.
6. Убедитесь, что масштаб осей соответствует данным.

<a id="prilozhenie-s-upravlenie-proizvoditelnostyu"></a>
## Приложение S. Управление производительностью
1. Используйте параметр `PIPELINE_MAX_CORES` для ограничения числа потоков.
2. При обработке большого числа пар заранее очищайте каталог `output`.
3. Сохраняйте промежуточные результаты после каждой десятой пары, чтобы избежать потери данных при сбое.
4. Логи регулярно архивируйте, чтобы не переполнять диск.

<a id="prilozhenie-t-proverka-korrektnosti-teoreticheskih-krivyh"></a>
## Приложение T. Проверка корректности теоретических кривых
1. Запустите вспомогательный скрипт, который читает `H_*.npy` и `T_*.npy` и строит графики частот и времен затухания.
2. Сравните теоретические значения с опубликованными данными.
3. Убедитесь, что нет резких скачков между соседними точками.
4. Проверьте, что массивы не содержат повторяющихся значений оси.

<a id="prilozhenie-u-primer-shablona-otcheta"></a>
## Приложение U. Пример шаблона отчёта
1. Заголовок: «Отчёт по обработке данных спектроскопии, дата …».
2. Раздел 1: Сводка по количеству успешных аппроксимаций.
3. Раздел 2: Таблицы частот и времён затухания.
4. Раздел 3: Графики (частота, время, амплитуда, спектры).
5. Раздел 4: Анализ отклонений от теории.
6. Раздел 5: Рекомендации по улучшению измерений.

<a id="prilozhenie-v-dopolnitelnye-rekomendacii-po-testirovaniyu"></a>
## Приложение V. Дополнительные рекомендации по тестированию
1. Создайте набор синтетических сигналов с известными параметрами.
2. Проверьте, что программа восстанавливает параметры с ошибкой менее 1%.
3. Протестируйте сценарии отсутствия теории и сравните с ручными расчётами.
4. Выполните стресс-тест на большом числе наборов, контролируя время выполнения.
5. Напишите тест, проверяющий корректность визуализации времени затухания (например, проверка наличия трёх панелей).
